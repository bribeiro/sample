/************************************************************************************* Author: Bruno Ribeiro && Rob.OT* Usage:*Open the fla that you want to export to xml*Run this command*The file will be saved inside the same folder of the fla.************************************************************************************/// adding method to the prototypeString.prototype.append = function(node){xml += "\n" + node; };fl.outputPanel.clear();// caching variablesvar doc = fl.getDocumentDOM();var lib = fl.getDocumentDOM().library;var items = lib.items;var item;var curvedWall;var forceElement;// Element propertiesvar elementBaseClass;//linkageClassNamevar elementClass;//linkageClassNamevar elementType;//itemTypevar elementX;var elementY;var elementRotation;var elementZIndex;var elementZIndex;var elementName;var elementRotation;// counter to help to see when we need to close the tagvar tileCounter = 0;var count = 0;		// Don't know if it's needed, but...	var xml= '<?xml version="1.0" encoding="utf-8"?>';		// append the root element	appendToXML("<elements>");			// get all the elements from the library	for (var i = 0; i < items.length; i++)	{		item = items[i];				if(item.name.indexOf("CurvedWall") >= 0)		{			curvedWall = item;		}				if(item.name.indexOf("ForceElement") >=0 )		{			forceElement = item;		}			// check if it's a tile		if (item.name.indexOf("Tile") >= 0 && item.name.indexOf("ph") < 0 && item.name.indexOf("Model") < 0)		{			// close tag			if (tileCounter  > 0)			{				appendToXML("</tile>");			}				var tileName = item.linkageClassName.split("Tile").join("");			tileName = tileName.split("_");						if(tileName[1] == 0)				// open tag								appendToXML("\n<tile name='" + item.linkageClassName + "' row='" + tileName[0]+ "'>");			else				appendToXML("\n<tile name='" + item.linkageClassName + "'>");			// counter to know if we need to close the tag			tileCounter++;						// select element timeline			var timeline = item.timeline;						var storeMaxDepth = 0 ; 			for (var j = 0; j < timeline.layerCount; j++)			{				for (var k = 0; k < timeline.layers[j].frameCount; k++)				{					// elements from this tile					var elements = timeline.layers[j].frames[k].elements;					count = -1;					for (var m = 0; m < elements.length; m++)					{						if (elements[m].name == "physics_mc")						{							var elementTL = elements[m].libraryItem.timeline;														//eL == Element Layers							for (var eL = elementTL.layerCount-1; eL >= 0 ; eL--)							{																	var eF = 0;									// elements from this tile									var childrens = elementTL.layers[eL].frames[eF].elements;																		//fl.trace("NumChildres: " + chidrens.length);									for (var eC = childrens.length-1; eC >= 0 ; eC--)									{										count = count +1;										////element from library to get class info										var libraryElement = childrens[eC].libraryItem;										if (childrens[eC].libraryItem)										{											elementBaseClass = libraryElement.linkageBaseClass;											elementClass = libraryElement.linkageClassName;											elementType = libraryElement.itemType;																																	if(elementClass.indexOf("_") >= 0)											{												elementClass = elementClass.slice(0, elementClass.indexOf("_"));												elementClass = elementClass.split("Item").join("Element");											}																																//element from the stage to get instance info											elementX= childrens[eC].x;											elementY= childrens[eC].y;											elementWidth= childrens[eC].width;											elementHeight= childrens[eC].height;											elementName= childrens[eC].name;											elementRotation= childrens[eC].rotation;																												var newEc = eC + storeMaxDepth ; 											var el = elementClass.substr(0,3);												//fl.trace('el :' + el)											switch ( el )											{												case 'Cur' :													createCurveNode( newEc );													break;												case 'Mov' :													createMovingObjectNode( newEc );													break;												case 'For' :													createForceObjectNode( newEc );													break;													default :													createGenericNode( newEc );													break;											}												elementX= null;											elementY= null;											elementWidth= null;											elementHeight= null;											elementName= null;											elementRotation= null;																																	delete elementX;											delete elementY;											delete elementWidth;											delete elementHeight;											delete elementName;											delete elementRotation;																						}																												}								storeMaxDepth = storeMaxDepth + childrens.length ; 							}							}						}				}							}		}	}		function createMovingObjectNode(index)	{		var totalFrames = elementTL.layers[eL].frameCount;		if(elementTL.layers[eL].frames[totalFrames - 1].elements[eC])		{			var endX = elementTL.layers[eL].frames[totalFrames - 1].elements[eC].x;			var endY = elementTL.layers[eL].frames[totalFrames - 1].elements[eC].y;			var endWidth = elementTL.layers[eL].frames[totalFrames - 1].elements[eC].width;			var endHeight = elementTL.layers[eL].frames[totalFrames - 1].elements[eC].height;			var endRotation = elementTL.layers[eL].frames[totalFrames - 1].elements[eC].rotation;				// adding node to the xml			appendToXML("\t<" + elementClass.toLowerCase() + " initialX='" + sliceValue(elementX) + "' initialY='" + sliceValue(elementY) + "' frames='" + totalFrames+  "' initialWidth='" + sliceValue(elementWidth) + "' initialHeight='" + sliceValue(elementHeight) + "' initialRotation='" + sliceValue(elementRotation) + "' zIndex='" + index + "' class='" + elementClass + "' type='" + index + "' endX='" + sliceValue(endX) + "' endY='" + sliceValue(endY) + "' endHeight='" + sliceValue(endHeight) + "' endWidth='" + sliceValue(endWidth) + "' endRotation='" + sliceValue(endRotation) + "' />");		}				}	function createForceObjectNode(index)	{		var forceTL = libraryElement.timeline;		var force = forceTL.layers[1].frames[0].elements[0].getTextString();			// adding node to the xml		appendToXML("\t<" + elementClass.toLowerCase() + " x='" + sliceValue(elementX) + "' y='" + sliceValue(elementY) + "' width='" + sliceValue(elementWidth) + "' height='" + sliceValue(elementHeight) + "' zIndex='" + index + "' class='" + elementClass +  "' rotation='" + sliceValue(elementRotation) + "' magnitude='" + force + "' />");	}		function createGenericNode(index)	{				// adding node to the xml		appendToXML("\t<" + elementClass.toLowerCase() + " x='" + sliceValue(elementX) + "' y='" + sliceValue(elementY) + "' width='" + sliceValue(elementWidth) + "' height='" + sliceValue(elementHeight) + "' zIndex='" + index + "' class='" + elementClass + "' rotation='" + sliceValue(elementRotation) + "' />");	}	function createCurveNode(index)	{		appendToXML("\t<" + elementClass.toLowerCase() + " x='" + sliceValue(elementX) + "' y='" + sliceValue(elementY) + "' width='" + sliceValue(elementWidth) + "' height='" + sliceValue(elementHeight) + "' zIndex='" + index + "' class='" + elementClass +  "' rotation='" + sliceValue(elementRotation) + "'>");		var curvedElementTL = libraryElement.timeline;		var nodes = new Array();					for (var a = 0; a < curvedElementTL.layerCount; a++)		{			for (var b = 0; b < curvedElementTL.layers[a].frameCount; b++)			{				var points = curvedElementTL.layers[a].frames[b].elements;				for (var c = 0; c < points.length; c++)				{					var libraryCurvedElement = points[c].libraryItem;					if (childrens[eC].libraryItem)					{						// creating node						var rot = sliceValue(points[c].rotation);						if(isNaN(rot))						rot = 0;						var nd = "<point x='" + sliceValue(points[c].x) + "' y='" + sliceValue(points[c].y) + "' rotation= '" + rot + "' />";						// adding node to the xml						nodes.push({"node":nd,"x":sliceValue(points[c].x)});					}				}					nodes.sort(function(a, b){				 return a.x-b.x				});				for (var pqp = 0; pqp < nodes.length; pqp++)				{					appendToXML("\t\t"+nodes[pqp].node);				}					appendToXML("\t</"+ elementClass.toLowerCase() + ">");			}			}	}			function appendToXML (value) {		fl.trace(value);		// xml.append(value);	}		function sliceValue (value) {		//value = value.toString();		//var pointPosition = value.indexOf(".");		//if(pointPosition >= 0)		//{		//	var decimals = value.slice(pointPosition);		//	if(decimals.length > 2)	//		value = value.slice(0, pointPosition) + "" + decimals;	//	}	//	fl.trace(value);		return parseInt(value, 10);	}			//	// closing the last tags	appendToXML("</tile>");	appendToXML("</elements>");		lib.selectNone();			//clear the panel to prepare to save the xml	// flash.outputPanel.clear();		//// write the xml 	// flash.trace(xml);		//get the document name	var exportFileName = doc.pathURI;	var index = exportFileName.indexOf("assets/");	exportFileName = exportFileName.slice(0,index);	exportFileName = exportFileName + "bin/assets/xml/"+doc.name.replace(/\.fla$/,"") + ".xml";	//exportFileName +=  doc.name.replace(/\.fla$/,"") + ".xml";		// saving output panel	flash.outputPanel.save(exportFileName);			fl.outputPanel.clear();//		fl.trace("File saved at: " + "bin/assets/xml/"+doc.name.replace(/\.fla$/,"")+ ".xml");	doc.publish();