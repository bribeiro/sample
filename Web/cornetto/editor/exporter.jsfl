/*********************************************************************************** * * Author: Bruno Ribeiro * Usage: *	Open the fla that you want to export to xml *	Run this command *	The file will be saved inside the same folder of the fla. * ***********************************************************************************/// adding method to the prototypeString.prototype.append = function(node) {	xml += "\n" + node;};// caching variablesvar doc = fl.getDocumentDOM();var lib = fl.getDocumentDOM().library;var items = lib.items;var item;var curvedWall;var forceElement;// Element propertiesvar elementBaseClass; //linkageClassNamevar elementClass; //linkageClassNamevar elementType; //itemTypevar elementX;var elementY;var elementRotation;var elementZIndex;var elementName;var elementRotation;// counter to help to see when we need to close the tagvar tileCounter = 0;function createXML() {	// Don't know if it's needed, but...	var xml = '<?xml version="1.0" encoding="utf-8"?>';	// append the root element	xml.append("<elements>");	// get all the elements from the library	for (var i = 0; i < items.length; i++) {		item = items[i];		if (item.name.indexOf("CurvedWall") >= 0) {			curvedWall = item;		}		if (item.name.indexOf("ForceElement") >= 0) {			forceElement = item;		}		// check if it's a tile		if (item.name.indexOf("Tile") >= 0 && item.name.indexOf("ph") < 0 && item.name.indexOf("Model") < 0) {			// close tag			if (tileCounter > 0) {				xml.append("\t</tile>");			}			// open tag			xml.append("\t<tile name='" + item.linkageClassName + "'>");			// counter to know if we need to close the tag			tileCounter++;			// select element from the stage			lib.selectItem(item);			lib.editItem();			// select element timeline			var timeline = item.timeline;			for (var j = 0; j < timeline.layerCount; j++) {				for (var k = 0; k < timeline.layers[j].frameCount; k++) {					// elements from this tile					var elements = timeline.layers[j].frames[k].elements;					for (var m = 0; m < elements.length; m++) {						if (elements[m].name == "physics_mc") {							var elementTL = elements[m].libraryItem.timeline;							//eL == Element Layers							for (var eL = 0; eL < elementTL.layerCount; eL++) {								//eF == Element Frames								//for (var eF = 0; eF < elementTL.layers[eL].frameCount; eF++)								//{								var eF = 0;								// elements from this tile								var childrens = elementTL.layers[eL].frames[eF].elements;								//fl.trace("NumChildres: " + chidrens.length);								for (var eC = 0; eC < childrens.length; eC++) {									////element from library to get class info									var libraryElement = childrens[eC].libraryItem;									if (childrens[eC].libraryItem) {										elementBaseClass = libraryElement.linkageBaseClass;										elementClass = libraryElement.linkageClassName;										elementType = libraryElement.itemType;										//element from the stage to get instance info										elementX = childrens[eC].x;										elementY = childrens[eC].y;										elementWidth = childrens[eC].width;										elementHeight = childrens[eC].height;										elementZIndex = eC; //(childrens.length -1) - eC;										elementName = childrens[eC].name;										elementRotation = childrens[eC].rotation;										var el = elementClass.substr(0, 3);										//fl.trace('el :' + el)										switch (el) {											case 'Cur':												createCurveNode();												break;											case 'Mov':												createMovingObjectNode();												break;											case 'For':												createForceObjectNode();												break;											default:												createGenericNode();												break;										}										if (elementClass != "CurvedWall") {										} else {										}									}									//}								}							}						}					}				}			}		}	}	function createMovingObjectNode() {		var totalFrames = elementTL.layers[eL].frameCount;		var endX = elementTL.layers[eL].frames[totalFrames - 1].elements[eC].x;		var endY = elementTL.layers[eL].frames[totalFrames - 1].elements[eC].y;		var endWidth = elementTL.layers[eL].frames[totalFrames - 1].elements[eC].width;		var endHeight = elementTL.layers[eL].frames[totalFrames - 1].elements[eC].height;		var endRotation = elementTL.layers[eL].frames[totalFrames - 1].elements[eC].rotation;		// creating node		var node = "\t\t<" + elementClass.toLowerCase() + " initialX='" + elementX + "' initialY='" + elementY + "' frames='" + totalFrames + "' initialWidth='" + elementWidth + "' initialHeight='" + elementHeight + "' initialRotation='" + elementRotation + "' zIndex='" + elementZIndex + "' class='" + elementClass + "' type='" + elementType + "' baseClass='" + elementBaseClass + "' name='" + elementName + "' endX='" + endX + "' endY='" + endY + "' endHeight='" + endHeight + "' endWidth='" + endWidth + "' endRotation='" + endRotation + "' />";		// adding node to the xml		xml.append(node);	}	function createForceObjectNode() {		var forceTL = libraryElement.timeline;		var force = forceTL.layers[0].frames[0].elements[1].getTextString();		// creating node		var node = "\t\t<" + elementClass.toLowerCase() + " x='" + elementX + "' y='" + elementY + "' width='" + elementWidth + "' height='" + elementHeight + "' zIndex='" + elementZIndex + "' class='" + elementClass + "' type='" + elementType + "' baseClass='" + elementBaseClass + "' name='" + elementName + "' rotation='" + elementRotation + "' magnitude='" + force + "' />";		// adding node to the xml		xml.append(node);	}	function createGenericNode() {		// creating node		var node = "\t\t<" + elementClass.toLowerCase() + " x='" + elementX + "' y='" + elementY + "' width='" + elementWidth + "' height='" + elementHeight + "' zIndex='" + elementZIndex + "' class='" + elementClass + "' type='" + elementType + "' baseClass='" + elementBaseClass + "' name='" + elementName + "' rotation='" + elementRotation + "' />";		// adding node to the xml		xml.append(node);	}	function createCurveNode() {		var node = "\t\t<" + elementClass.toLowerCase() + " x='" + elementX + "' y='" + elementY + "' width='" + elementWidth + "' height='" + elementHeight + "' zIndex='" + elementZIndex + "' class='" + elementClass + "' type='" + elementType + "' baseClass='" + elementBaseClass + "' name='" + elementName + "' rotation='" + elementRotation + "'>";		xml.append(node);		var curvedElementTL = libraryElement.timeline;		var nodes = new Array();		for (var a = 0; a < curvedElementTL.layerCount; a++) {			for (var b = 0; b < curvedElementTL.layers[a].frameCount; b++) {				var points = curvedElementTL.layers[a].frames[b].elements;				for (var c = 0; c < points.length; c++) {					var libraryCurvedElement = points[c].libraryItem;					if (childrens[eC].libraryItem) {						//element from the stage to get instance info						elementX = points[c].x;						elementY = points[c].y;						elementWidth = points[c].width;						elementHeight = points[c].height;						elementZIndex = c; //(points.length -1) - c;						elementName = points[c].name;						elementRotation = points[c].rotation;						// creating node						var node = "\t\t\t<point x='" + elementX + "' y='" + elementY + "' rotation= '" + elementRotation + "' zIndex='" + elementZIndex + "' />";						// adding node to the xml						nodes.push({							"node": node,							"x": elementX						});					}				}				nodes.sort(function(a, b) {					return a.x - b.x				});				for (var pqp = 0; pqp < nodes.length; pqp++) {					xml.append(nodes[pqp].node);				}				xml.append("\t\t</" + elementClass.toLowerCase() + ">");			}		}	}	function duplicateCurve() {		var counter = 0;		for (var i = 0; i < items.length; i++) {			if (!lib.itemExists("curves/CurvedWallItem_" + i)) {				counter = i;				break;			}		}		lib.duplicateItem(curvedWall.name);		var newCurve = lib.getSelectedItems()[0];		lib.renameItem("CurvedWallItem_" + counter);		newCurve.linkageIdentifier = "CurvedWallItem_" + counter;		newCurve.linkageClassName = "CurvedWallItem_" + counter;		lib.moveToFolder("curves", newCurve.name);		lib.updateItem(newCurve.name);		lib.selectNone();	}	function duplicateForce() {		var counter = 0;		for (var i = 0; i < items.length; i++) {			if (!lib.itemExists("force/ForceItem_" + i)) {				counter = i;				break;			}		}		lib.duplicateItem(forceElement.name);		var newForce = lib.getSelectedItems()[0];		lib.renameItem("ForceItem_" + counter);		newForce.linkageIdentifier = "ForceItem_" + counter;		newForce.linkageClassName = "ForceItem_" + counter;		lib.moveToFolder("force", newForce.name);		lib.updateItem(newForce.name);		lib.addItemToDocument({			x: 0,			y: 0		}, newForce.name);		lib.selectNone();	}	//	// closing the last tags	xml.append("\t</tile>");	xml.append("</elements>");	//clear the panel to prepare to save the xml	flash.outputPanel.clear();	// write the xml 	flash.trace(xml);	//get the document name	var exportFileName = doc.pathURI;	var index = exportFileName.indexOf("assets/");	exportFileName = exportFileName.slice(0, index);	exportFileName = exportFileName + "bin/assets/xml/";	exportFileName += doc.name.replace(/\.fla$/, "") + ".xml";	// saving output panel	flash.outputPanel.save(exportFileName);	//fl.outputPanel.clear();	fl.trace("File saved at: " + "bin/assets/xml/" + doc.name.replace(/\.fla$/, "") + ".xml");	// confirm the file path	//fl.getDocumentDOM().publish();}//duplicateCurve();//duplicateForce();